### HTTP 1.0

 核心诉求是：支持多种类型的文件下载  引入请求头 请求体 状态码

 请求头告诉服务器期待返回的文件**类型，压缩方式 编码**

浏览器最终还是需要根据响应头的信息来处理数据

提供Cache机制，减轻服务器的压力，缓存已经下载过的数据

### HTTP 1.1

+ 持久连接 一个TCP连接上可以传输多个HTTP请求

     浏览器为每个域名最多同时维护6个TCP持久连接、

     使用CDN实现域名分片机制

+ 客户端cookie

+ 缺点

     1. tcp慢启动，会推迟宝贵的首次渲染页面的时间

     2. 开启多条tcp连接，会竞争固定的带宽，一开始慢启动，各个连接占用带宽增加，当带宽不够，

     ​       连接减少接受数据的速度，各个tcp之间无法协商，影响到一些关键的资源下载

     3. 在同一个tcp管道中，同一时刻只能处理一个请求，浏览器不知道接受到的响应是哪一个 对头阻塞
     4. 在一条tcp连接中，一个数据丢包，会发生队头的阻塞，其他的请求不会发生阻塞

### HTTP 2.0

规避tcp慢启动，多个tcp之间的竞争问题

+ 多路复用

   一个域名只使用一个TCP长连接，只有一次慢启动

  资源的并行请求，可以在任何时候发送请求。

  每个请求都有一个ID，将请求分为不同的帧时，每个帧具有相同的ID，可以控制请求的优先级

​       在一个tcp请求中，只要一个一个请求的帧的包丢失，会阻塞所有的请求

### HTTP 3.0

建立在UDP之上 ，没有握手的RTT时间  2.5个RTT

集成了TCP可靠传输，TLS安全加密,复用技术

交易连接的Session ID缓存在浏览器内存，再次打开，无需再建立TLS连接

RTT: 浏览器与服务器通信的一来一回

1. TCP建立的链接 1.5RTT

2. TCP运行HTTP request  1RTT

3. TLS连接    1.5RTT(1.2)   

### 缓存

![缓存](C:\Users\Administrator\Desktop\缓存.jpg)

+ 强缓存

  Cache Control : max-age 当超过间隔的秒数时，缓存失败 否则 返回200 from cache memory

  ​                            no-cache 不使用强缓存，需要向服务器验证缓存是否新鲜

  Pragma: no-cache与上面的用法一致，且优先级优于Cache Control

+ 协商缓存 需要验证一些字段 新鲜 返回304

  Etag：当前资源在服务器生成的唯一标识，当再次请求服务器时，if-None-Match：缓存中获取的唯一标识。       服务器收到后,将此标识与计算的标识做对此。

  Last-Modified: 
  
  服务器在响应请求时，告诉浏览器资源最后修改的时间。if-Modified-Since:在 缓存中获得 的  最后修改时间,与请求资源的最后修改时间进行对比，
  当文件的修改频率在秒级以下，会错误的返回304,控制不了秒级
  
  当文件被修改，当时内容没有发生任何更改，比如增加一个空格，删除一个空格

### web数据存储方式

cookie：可以设置失效时间，没有设置的话，默认是关闭浏览器后失效。

​                存储在浏览器里的一个小小的文本文件，附着在HTTP请求上，在浏览器和服务器之间来回传递

​                服务端生成，客户端维护 告知服务端两个请求是否来自同一个浏览器

​                设置cookie的过期时间为Session 则是说明当关闭浏览器，则当前cookie失效

session: 当关闭页面或浏览器后就会被清除，产生一个sessionID,将其放至cookie中
               将sessionID都放置在缓存数据库中，在分布式服务器上
               将在nginx配置中，ip_hash将统一ip都打到同一个服务器下。

在后台开发系统中，刷新浏览器后，vuex中的存储的数据会丢失，为了不是每次都到登录页，将token放置在cookie中，在vuex中 state.cookie = getToken()。或者从永久性本次存储系统中拿到Token,放置在请求头的参数中

### 解决跨域的问题

同源策略模式下，可以发起访问后台服务器，且返回了数据，只是服务器拦截了

+ 代理的方式

+ jsonp    页面中的script img iframe标签 天然跨域 后端返回一段js代码(调用约好了的回调函数)，只支持get

+ cors  跨站资源共享 发起预检请求 添加一系列请求头的字段名

+ document.domian 在页面之间通过js指定主级域名，相同

+ websocket协议栈  请求的源中有Origin 发自哪个域名

+ http-proxy-middleware  2次跨域

+ vue webpack-dev-serve

  ```js
  function jsonp({url,param,cb}){
      return new Promise(resolve=>{
          let script = document.createElement('script')
          window[cb] = function(params){
              resolve(params)
          }
          params = {...param,cb}
          let arrs = []
          for(let key of params){
               arrs.push(`${key}=${param[key]}`)
          }
          script.src = `${url}?${arrs.join('&')}`
          document.body.appendChild(script)
      })
  }
  
  ```
  
  a标签download属性可以下载同源的图片
  
  不同源，通过canvas设置图片的crossOrigin:'anoymous'解决跨域问题，避免画布污染再将图片转为base64 blob等付给a标签的href。
  
  默认情况下，图片天然的跨域，不会携带有Origin
  
  避免浏览器缓存资源与请求头，1. vary:Origin  未配置Vary之前，浏览器的缓存以url为唯一区分，配置Vary后，浏览器会以二者结合作为区分
  
  ​                                                      2. 获取图片+ 随机时间戳

### 原型链

  实例成员：通过this添加的成员，只能通过实例化对象来访问 p = new Person()

  静态成员：在构造函数上添加的成员，只能通过构造函数来访问 Persion.name

  每个对象都有\__proto__原型指向构造函数的prototype

  构造器指向构造函数 prototype.constructor == 构造函数Person 在写插件时，暴露出来的都是实例化后的对象，要想扩展原型方法 xx.\__proto__ 或者xx.constructor.prototype，因此为了能拿到正确的原型对象，所以需要修复构造器。

  继承：原型链继承，A,B在B中A.call(this) B.prototype === new A(）造成了存在对A中变量的两次拷贝。

  ​           若是直接 B.prototype === A.prototype 会导致修改B的原型对象会影响到A的原型对象

     1. B.prototype = object.create(A.prototype) 拷贝一份对象使得B.prototype.\__proto__ 指向A原型
      
     2. 使用空对象
      
        ```js
        都是通过让child.prototype.__proto__指向parent.prototype这样改变一个时，另一个就不会发生改变
        function extend(parent,child){
            function x(){}
            x.prototype = parent.prototype
            child.prototype = new x()  // 
        }
        ```
es5的继承

通过先生成子类的实例对象，再将父类得方法添加到子类的this上

es6的继承

super(this)代表的是父类的构造函数，在父类的构造函数中最终返回的是B的实例对象，

 class中的方法都没有prototype属性 都不能通过new生成

  ### 数据库密码

  salt:增加密码的复杂度 + 避免盐被盗了

  MD5(password + salt + ‘448^&^%f320jffjwei')

  ### Web攻击

  xss  跨站脚本攻击，运行非法的非本站点的script脚本

  ​        将非法脚本伪装，可以在脚本里面运行窃取用户的cookie等个人信息 ，

  ​                                      客户端将这些非法脚本写到数据库里，破坏危害更大

  csrf 跨站请求伪造  用户登录了A网站，在没有退出A网站下，去访问了B网站，B网站模拟该用户去对A站点进行一些操作。验证码 添加jwbToken放在请求头的Authorization字段中

###   js运行机制

进程：cpu资源分配的最小单位，系统会分配内存

线程：一个进程有多个线程，共享一个进程内的资源，内存空间

浏览器是多进程，每打开一个Tab页，就是创建了一个独立的浏览器进程。

**Browser进程**：浏览器的主进程（负责协调，主控

​                       负责浏览器的界面显示，用户交互，前进，后退。

​                       创建和销毁其他的进程

​                        将renderer进程得到的内存只给你的图层，绘制到用户界面上。

 **第三方插件进程**：每种类型的插件对应一个进程，当使用该插件时才创建

 **GPU进程**：3D绘制

 **渲染进程：**（内部多线程）每个Tab页面一个进程，页面渲染，脚本执行，事件处理

+ GUI渲染线程： 负责渲染浏览器界面，解析HTML,CSS,构建DOM树和render树，布局绘制

​                                  页面需要重绘或者回流时，该线程会执行

+ JS引擎线程 :解析，运行JS脚本程序，只有一个，与渲染线程互斥
+ 定时器触发线程：负责计时，
+ 事件触发线程，当遇到setTimout,Ajax等的异步请求时，将其添加到事件线程中，当时机触发，放在待处理的任务队列的末尾，等待JS线程去执行

​    webwork：JS线程申请开的一个子线程，，不能操作DOM,通过post-onMessage进行通信

HTML文档的解析过程

从上到下立即执行，遇到link,img标签，会重新起一个线程去解析，下载该资源

遇到普通script标签时，立即解析并执行，async：异步解析文件，当文件被下载完成以后，立即执行。

​                                                                        defer:异步解析，下载完成后，等到整个文档解析后，再去执行。

DOMContentLoaded，只是文档被解析（js,css）执行完成，DOM树构建完成，其他的img,video等其他外部资源没有拿到。

loaded是页面所有的资源都加载完成

### 回流与重绘

render tree能识别样式，不包含隐藏的节点 display:none节点。

重绘：元素属性只是影响元素的外观，风格，而不会影响布局，

回流：会重新构造受到影响的渲染树，在将这部分渲染树绘制到屏幕中。

浏览器会维护一个队列，把所有引起回流，重绘的操作放入这个队列， 当操作达到一定的数量或者到了一定的时间间隔，浏览器就会flush队列进行一个批处理。

当需要获取精确的值，比如offsetTop，scrollTop,clientTop,width等强制更新队列。

减少回流重绘就是减少对render tree的操作(合并多次多DOM和样式的修改，减少对一些style样式的请求)

​                                    1.创建documentFragment，在其上面应用所有的Dom操作，最后再将其添加到文档中

​                                     2.为元素设置display:none，在该节点上进行DOM操作不会引起回流重绘。

复合层性能优化：  

硬件加速：会声明一个新的复合图层，会单独分配资源，不管这个图层中怎么变化，也不会影响默认图层里的回流重绘，各个复合图层单独绘制，互不影响。避免，需要绘制整个复合的图层  translate3D,translateZ，opacity

最原始的普通问文档流，包括absolute，脱离文档流的仍然属于默认复合图层。

复杂动画，减少动画元素对其他元素的影响，需要将动画效果中的元素提升为合成层

preload:提示浏览器要优先获取对应的资源

prefetch:提示浏览器可能会用到，当浏览器空闲时，需要去加载对应的资源

### 预渲染 vue

prerender-spa-plugin 依赖puppeteer操作chromium无头浏览器内核，对需要预渲染的页面生成一个静态的HTML，里面是已经填好的dom节点和数据，直接给用户返回有内容的文档。

```js
//在组件挂载之后，触发预渲染这个事件
mounted: function(){
            document.dispatchEvent(new Event('render-event'));
 },
```

### 鉴权

jsonwebtoken：生成token,有效日期，证书等

jwt:鉴权；如果鉴权失败，返回401

```js
//设置
ctx.body = {
    message:'登录成功',
    user:userInfo,
    token:jwt.sign({data:userinfo,exp:Math.floor(Date.now() /1000)+60*60},secret)
}
//验证 路由可以写多个中间件
router.get('/users/getUser-token',jwtAuth({secret}),async (ctx,next)=>{
    //这里鉴权成功,才会走到这一步
    ctx.body = {
        message:'获取数据成功',
        userInfo:ctx.state.user.data//将数据存储在这里了
    }
})
token:令牌头 载荷(含有信息) hash防篡改
```

Oauth2.0 认证

```js
用户允许第三方服务器通过accss_token拿到用户在github的信息，一般是用户名，头像等
1.用户打开客户端(第三方服务器),客户端请求资源所有者（用户）授权----github的授权认证页面。
2.用户同意授权后，github(认证服务器)会返回给客户端授权认证码code
3.客户端拿到授权认证码以后，向github申请用户的访问令牌
4.客户端根据令牌，向资源所有者(用户，github账号),申请获得开发的资源
```

SSO单点登录

![用户B](C:\Users\Administrator\Desktop\用户B.png)

```js
重定向到统一的认证中心进行登录验证
1:用户先与认证服务建立会话，此时的cookie域是用户到认证中心
2:用户访问站点B时重定向到认证中心时，是同一个域，因此会带上cookie到认证中心
3:认证中心返回的系统A一个tiket,A再向认证中心去获取用户的token，与用户再次建立自己的session会话
```

### 事件捕获 冒泡 代理

```js
addEventListener('click',function(),true/false) true：事件在捕获阶段执行 false:在冒泡阶段执行
捕获阶段：事件从上一级标签开始往下查找，直到捕获到target
冒泡阶段：事件从target开始，往上冒泡直到页面的最上一节标签
event.target 引起触发事件的真正元素 event.currentTarget 冒泡/捕获时的当前对象 
事件一般是在冒泡阶段触发。
js   xx.cancelBubble=true;阻止冒泡 e.stopPropagation()
react  合成事件e.stopPropagation() 原生事件e.nativeEvent.stopImmediatePropagation();
vue  @click.stop="xxx"
```

### node单进程，多线程

node多线程 是在libuv中存在线程

只由主进程监听端口，将连接通过时间片轮转法的调度策略  将请求通过 IPC 管道分发给子进程，由子进程去处理

子进程只启动服务，不会真正监听端口。因为内部 listen 方法被 fake 成一个直接返回 0 的空方法，因此不会去真正监听端口

- V8 引擎解析 JavaScript 脚本。
- 解析后的代码，调用 Node API。
- libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
- V8 引擎再将结果返回给用户。

```js
node事件循环 高并发 支持异步IO，每当IO请求，提供一个线程给I/o,继续执行主线程，只处理该请求的回调 
一直执行队列里的任务，直到队列为空

timer队列        处理setTimeOut等的回调

​                -----------nextTick()  宏任务的回调

I/O callbacks   （除了时间等的回调函数外）所有事件的回调函数
 
poll队列         新的IO事件，网络连接 数据获取 读取文件  当事件回调队列为空，且timer超时，会去执行timer
check           setImmediate()回调
```

通信

Node 单机下 父子进程通过IPC通道 当创建子进程时，会先创建通信通道，

​    ------通过process.send()发消息 on监听message接受消息

cluster模块 master主控节点创建和销毁进程并与子进程通信，子进程之间不能直接通信、

worker节点负责执行耗时任务。

### electron

chromium + node.js + 原生GUI= electron

浏览器不能直接操作原生GUI能力，集成node.js 可以调用一些系统功能

### 项目

控制不同用户具有页面的权限

在router中，设置两份路由，一份是asyncRouter,(在路由的meta标签上上设置role角色)，一份是constRouter，用户登录成功后，获取用户的info(包含用户的角色），在路由守卫上，根据角色去获取相应 的动态路由的权限集，再使用router的router.addRoutes()添加至路由表中，在生成侧边栏时直接去获取该角色拥有的全部权限集。

后端维护不同的用户具有的不同权限，路由只有一份(在meta标签中，设置access, system:department,当用户具有这个权限集时，才生成导航栏，才有权限进入该页面),当用户通过浏览器跳转页面时，在全局路由守卫出做拦截，---找到要去的页面(to.name,routers),拿到该路由的权限集，如果该页面不限制(没有权限设置，直接next()),否则拿到权限集，判断用户的权限集里是否有这些权限，若有，则next(),否则 重定向到404页面。

对于按钮级别的细粒度控制，则也是由用户维护一份权限集，当该用户点击按钮去获取某个接口时，由后端判断该用户是否具有请求某个接口的能力，若没有，返回无权限

对于404页面

当用户跳转到404页面时，为了用户体验，根据code码，显示不同的页面,并且，

1.在错误页面，能显示回退到首页，以及上一页的按钮，在进入到40x界面后，mounted计时，设置多少秒之后，强制执行回退到上一个页面。this.$router.go(-1)

标签管理

1. watch监听$route，当路由改变时，添加标签（当前标签是否在TagLists中，若存在，不添加）

2. 计算属性返回TagLists,渲染Tag

3. 计算属性缓存TagLists组件，TagList组件中过滤掉meta标签中noCache的组件

4. 删除标签时，通过子组件通信的方式

   ```js
   单个：
   1.若删除的组件与当前路由不匹配，则只更新TagList，不做任何更改
   2.若删除的组件与当前路由匹配， 如果当前组件是最后一个，则要渲染前一个组件(路由跳转)
                             如果当前组件不是最后一个，则要渲染后一个组件(路由跳转)
     更新TagList，sideMenu的openName也要更新
   删除多个：
   1.删除的是 点击右键删除all TagList只保留home，跳转至Home页
   2.删除的是 other 只保留home和当前的路由，页面不跳转      
   ```

5. 给组件设置：value @input事件

​       tag标签绑定click事件，当点击tag时，跳转路由，同时改变组件上的value值，也就是当前的路由

6. 标签的滑动  通过控制body的left进行滑动，显示标签 

   ```ht
   <scroll-outer>
       <scroll-body left="动态改变的值">
   
       </scroll-body>
   </scroll-outer>
   
   
   ```

   
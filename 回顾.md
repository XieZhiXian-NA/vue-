### HTTP 1.0

 核心诉求是：支持多种类型的文件下载  引入请求头 请求体 状态码

 请求头告诉服务器期待返回的文件**类型，压缩方式 编码**

浏览器最终还是需要根据响应头的信息来处理数据

提供Cache机制，减轻服务器的压力，缓存已经下载过的数据

### HTTP 1.1

+ 持久连接 一个TCP连接上可以传输多个HTTP请求

     浏览器为每个域名最多同时维护6个TCP持久连接、

     使用CDN实现域名分片机制

+ 客户端cookie

+ 缺点

     1. tcp慢启动，会推迟宝贵的首次渲染页面的时间

     2. 开启多条tcp连接，会竞争固定的带宽，一开始慢启动，各个连接占用带宽增加，当带宽不够，

     ​       连接减少接受数据的速度，各个tcp之间无法协商，影响到一些关键的资源下载

     3. 在同一个tcp管道中，同一时刻只能处理一个请求，浏览器不知道接受到的响应是哪一个 对头阻塞
     4. 在一条tcp连接中，一个数据丢包，会发生队头的阻塞，其他的请求不会发生阻塞

### HTTP 2.0

规避tcp慢启动，多个tcp之间的竞争问题

+ 多路复用

   一个域名只使用一个TCP长连接，只有一次慢启动

  资源的并行请求，可以在任何时候发送请求。

  每个请求都有一个ID，将请求分为不同的帧时，每个帧具有相同的ID，可以控制请求的优先级

​       在一个tcp请求中，只要一个一个请求的帧的包丢失，会阻塞所有的请求

### HTTP 3.0

建立在UDP之上 ，没有握手的RTT时间  2.5个RTT

集成了TCP可靠传输，TLS安全加密,复用技术

交易连接的Session ID缓存在浏览器内存，再次打开，无需再建立TLS连接

RTT: 浏览器与服务器通信的一来一回

1. TCP建立的链接 1.5RTT

2. TCP运行HTTP request  1RTT

3. TLS连接    1.5RTT(1.2)   

### 缓存

![缓存](C:\Users\Administrator\Desktop\缓存.jpg)

+ 强缓存

  Cache Control : max-age 当超过间隔的秒数时，缓存失败 否则 返回200 from cache memory

  ​                            no-cache 不使用强缓存，需要向服务器验证缓存是否新鲜

  Pragma: no-cache与上面的用法一致，且优先级优于Cache Control

+ 协商缓存 需要验证一些字段 新鲜 返回304

  Etag：当前资源在服务器生成的唯一标识，当再次请求服务器时，if-None-Match：缓存中获取的唯一标识。       服务器收到后,将此标识与计算的标识做对此。

  Last-Modified: 
  
  服务器在响应请求时，告诉浏览器资源最后修改的时间。if-Modified-Since:在 缓存中获得 的  最后修改时间,与请求资源的最后修改时间进行对比，
  当文件的修改频率在秒级以下，会错误的返回304,控制不了秒级
  
  当文件被修改，当时内容没有发生任何更改，比如增加一个空格，删除一个空格

### web数据存储方式

cookie：可以设置失效时间，没有设置的话，默认是关闭浏览器后失效。

​                存储在浏览器里的一个小小的文本文件，附着在HTTP请求上，在浏览器和服务器之间来回传递

​                服务端生成，客户端维护 告知服务端两个请求是否来自同一个浏览器

​                设置cookie的过期时间为Session 则是说明当关闭浏览器，则当前cookie失效

session: 当关闭页面或浏览器后就会被清除，产生一个sessionID,将其放至cookie中
               将sessionID都放置在缓存数据库中，在分布式服务器上
               将在nginx配置中，ip_hash将统一ip都打到同一个服务器下。

在后台开发系统中，刷新浏览器后，vuex中的存储的数据会丢失，为了不是每次都到登录页，将token放置在cookie中，在vuex中 state.cookie = getToken()。或者从永久性本次存储系统中拿到Token,放置在请求头的参数中

### 解决跨域的问题

同源策略模式下，可以发起访问后台服务器，且返回了数据，只是服务器拦截了

+ 代理的方式

+ jsonp    页面中的script img iframe标签 天然跨域 后端返回一段js代码(调用约好了的回调函数)，只支持get

+ cors  跨站资源共享 发起预检请求 添加一系列请求头的字段名

+ document.domian 在页面之间通过js指定主级域名，相同

+ websocket协议栈  请求的源中有Origin 发自哪个域名

+ http-proxy-middleware  2次跨域

+ vue webpack-dev-serve

  ```js
  function jsonp({url,param,cb}){
      return new Promise(resolve=>{
          let script = document.createElement('script')
          window[cb] = function(params){
              resolve(params)
          }
          params = {...param,cb}
          let arrs = []
          for(let key of params){
               arrs.push(`${key}=${param[key]}`)
          }
          script.src = `${url}?${arrs.join('&')}`
          document.body.appendChild(script)
      })
  }
  
  ```
  
  a标签download属性可以下载同源的图片
  
  不同源，通过canvas设置图片的crossOrigin:'anoymous'解决跨域问题，避免画布污染再将图片转为base64 blob等付给a标签的href。
  
  默认情况下，图片天然的跨域，不会携带有Origin
  
  避免浏览器缓存资源与请求头，1. vary:Origin  未配置Vary之前，浏览器的缓存以url为唯一区分，配置Vary后，浏览器会以二者结合作为区分
  
  ​                                                      2. 获取图片+ 随机时间戳

​      referer：访问原始资源的URL，具体的路径，包含查询参 http://sasssoa.integrate.com/index.html?xxf

​     可以在nginx中设置valid_referers进行防盗链

​     Origin：http://sasssoa.intergarate.com  请求的来源 协议和域名

​      根据Origin请求头设置返回不同的Access-Control-Allow-Origin字段

​    浏览器的缓存是根据url，一个url一个缓存，当发起统一url请求，但是Access-Control-Allow-Origin不同就会引起跨域缓存错乱的情况。

```js
条件性的cores
a.taobao.com 
a.taobao.com的A页面通过img访问一个资源时，不跨域，浏览器缓存时，没有Access-Control-Allow-Origin字段
a.taobao.com的B页面通过ajax访问同一个资源时，此时浏览器有缓存，会出现跨域错误

Vary响应头就是让同一个 URL 根据某个请求头的不同而使用不同的缓存
```

### 原型链

  实例成员：通过this添加的成员，只能通过实例化对象来访问 p = new Person()

  静态成员：在构造函数上添加的成员，只能通过构造函数来访问 Persion.name

  每个对象都有\__proto__原型指向构造函数的prototype

  构造器指向构造函数 prototype.constructor == 构造函数Person 在写插件时，暴露出来的都是实例化后的对象，要想扩展原型方法 xx.\__proto__ 或者xx.constructor.prototype，因此为了能拿到正确的原型对象，所以需要修复构造器。

  继承：原型链继承，A,B在B中A.call(this) B.prototype === new A(）造成了存在对A中变量的两次拷贝。

  ​           若是直接 B.prototype === A.prototype 会导致修改B的原型对象会影响到A的原型对象

     1. B.prototype = object.create(A.prototype) 拷贝一份对象使得B.prototype.\__proto__ 指向A原型
      
     2. 使用空对象
      
        ```js
        都是通过让child.prototype.__proto__指向parent.prototype这样改变一个时，另一个就不会发生改变
        function extend(parent,child){
            function x(){}
            x.prototype = parent.prototype
            child.prototype = new x()  // 
        }
        ```
es5的继承

通过先生成子类的实例对象，再将父类得方法添加到子类的this上

es6的继承

super(this)代表的是父类的构造函数，在父类的构造函数中最终返回的是B的实例对象，

 class中的方法都没有prototype属性 都不能通过new生成

  ### 数据库密码

  salt:增加密码的复杂度 + 避免盐被盗了

  MD5(password + salt + ‘448^&^%f320jffjwei')

  ### Web攻击

  xss  跨站脚本攻击，运行非法的非本站点的script脚本

  ​        将非法脚本伪装，可以在脚本里面运行窃取用户的cookie等个人信息 ，

  ​                                      客户端将这些非法脚本写到数据库里，破坏危害更大

  csrf 跨站请求伪造  用户登录了A网站，在没有退出A网站下，去访问了B网站，B网站模拟该用户去对A站点进行一些操作。验证码 添加jwbToken放在请求头的Authorization字段中

###   js运行机制

进程：cpu资源分配的最小单位，系统会分配内存

线程：一个进程有多个线程，共享一个进程内的资源，内存空间

浏览器是多进程，每打开一个Tab页，就是创建了一个独立的浏览器进程。

**Browser进程**：浏览器的主进程（负责协调，主控

​                       负责浏览器的界面显示，用户交互，前进，后退。

​                       创建和销毁其他的进程

​                        将renderer进程得到的内存只给你的图层，绘制到用户界面上。

 **第三方插件进程**：每种类型的插件对应一个进程，当使用该插件时才创建

 **GPU进程**：3D绘制

 **渲染进程：**（内部多线程）每个Tab页面一个进程，页面渲染，脚本执行，事件处理

+ GUI渲染线程： 负责渲染浏览器界面，解析HTML,CSS,构建DOM树和render树，布局绘制

​                                  页面需要重绘或者回流时，该线程会执行

+ JS引擎线程 :解析，运行JS脚本程序，只有一个，与渲染线程互斥
+ 定时器触发线程：负责计时，
+ 事件触发线程，当遇到setTimout,Ajax等的异步请求时，将其添加到事件线程中，当时机触发，放在待处理的任务队列的末尾，等待JS线程去执行

​    webwork：JS线程申请开的一个子线程，，不能操作DOM,通过post-onMessage进行通信

HTML文档的解析过程

从上到下立即执行，遇到link,img标签，会重新起一个线程去解析，下载该资源

遇到普通script标签时，立即解析并执行，async：异步解析文件，当文件被下载完成以后，立即执行。

​                                                                        defer:异步解析，下载完成后，等到整个文档解析后，再去执行。

DOMContentLoaded，只是文档被解析（js,css）执行完成，DOM树构建完成，其他的img,video等其他外部资源没有拿到。

loaded是页面所有的资源都加载完成

### 回流与重绘

render tree能识别样式，不包含隐藏的节点 display:none节点。

重绘：元素属性只是影响元素的外观，风格，而不会影响布局，

回流：会重新构造受到影响的渲染树，在将这部分渲染树绘制到屏幕中。

浏览器会维护一个队列，把所有引起回流，重绘的操作放入这个队列， 当操作达到一定的数量或者到了一定的时间间隔，浏览器就会flush队列进行一个批处理。

当需要获取精确的值，比如offsetTop，scrollTop,clientTop,width等强制更新队列。

减少回流重绘就是减少对render tree的操作(合并多次多DOM和样式的修改，减少对一些style样式的请求)

​                                    1.创建documentFragment，在其上面应用所有的Dom操作，最后再将其添加到文档中

​                                     2.为元素设置display:none，在该节点上进行DOM操作不会引起回流重绘。

复合层性能优化：  

硬件加速：会声明一个新的复合图层，会单独分配资源，不管这个图层中怎么变化，也不会影响默认图层里的回流重绘，各个复合图层单独绘制，互不影响。避免，需要绘制整个复合的图层  translate3D,translateZ，opacity

最原始的普通问文档流，包括absolute，脱离文档流的仍然属于默认复合图层。

复杂动画，减少动画元素对其他元素的影响，需要将动画效果中的元素提升为合成层

preload:提示浏览器要优先获取对应的资源

prefetch:提示浏览器可能会用到，当浏览器空闲时，需要去加载对应的资源

### 预渲染 vue

prerender-spa-plugin 依赖puppeteer操作chromium无头浏览器内核，对需要预渲染的页面生成一个静态的HTML，里面是已经填好的dom节点和数据，直接给用户返回有内容的文档。

```js
//在组件挂载之后，触发预渲染这个事件
mounted: function(){
            document.dispatchEvent(new Event('render-event'));
 },
```

### 鉴权

jsonwebtoken：生成token,有效日期，证书等

jwt:鉴权；如果鉴权失败，返回401

```js
//设置
ctx.body = {
    message:'登录成功',
    user:userInfo,
    token:jwt.sign({data:userinfo,exp:Math.floor(Date.now() /1000)+60*60},secret)
}
//验证 路由可以写多个中间件
router.get('/users/getUser-token',jwtAuth({secret}),async (ctx,next)=>{
    //这里鉴权成功,才会走到这一步
    ctx.body = {
        message:'获取数据成功',
        userInfo:ctx.state.user.data//将数据存储在这里了
    }
})
token:令牌头 载荷(含有信息) hash防篡改
```

Oauth2.0 认证

```js
用户允许第三方服务器通过accss_token拿到用户在github的信息，一般是用户名，头像等
1.用户打开客户端(第三方服务器),客户端请求资源所有者（用户）授权----github的授权认证页面。
2.用户同意授权后，github(认证服务器)会返回给客户端授权认证码code
3.客户端拿到授权认证码以后，向github申请用户的访问令牌
4.客户端根据令牌，向资源所有者(用户，github账号),申请获得开发的资源
```

SSO单点登录

![用户B](C:\Users\Administrator\Desktop\用户B.png)

```js
重定向到统一的认证中心进行登录验证
1:用户先与认证服务建立会话，此时的cookie域是用户到认证中心
2:用户访问站点B时重定向到认证中心时，是同一个域，因此会带上cookie到认证中心
3:认证中心返回的系统A一个tiket,A再向认证中心去获取用户的token，与用户再次建立自己的session会话
```

### 事件捕获 冒泡 代理

```js
addEventListener('click',function(),true/false) true：事件在捕获阶段执行 false:在冒泡阶段执行
捕获阶段：事件从上一级标签开始往下查找，直到捕获到target
冒泡阶段：事件从target开始，往上冒泡直到页面的最上一节标签
event.target 引起触发事件的真正元素 event.currentTarget 冒泡/捕获时的当前对象 
事件一般是在冒泡阶段触发。
js   xx.cancelBubble=true;阻止冒泡 e.stopPropagation()
react  合成事件e.stopPropagation() 原生事件e.nativeEvent.stopImmediatePropagation();
vue  @click.stop="xxx"
```

### node单进程，多线程

node多线程 是在libuv中存在线程

只由主进程监听端口，将连接通过时间片轮转法的调度策略  将请求通过 IPC 管道分发给子进程，由子进程去处理

子进程只启动服务，不会真正监听端口。因为内部 listen 方法被 fake 成一个直接返回 0 的空方法，因此不会去真正监听端口

- V8 引擎解析 JavaScript 脚本。
- 解析后的代码，调用 Node API。
- libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
- V8 引擎再将结果返回给用户。

```js
node事件循环 高并发 支持异步IO，每当IO请求，提供一个线程给I/o,继续执行主线程，只处理该请求的回调 
一直执行队列里的任务，直到队列为空

timer队列        处理setTimeOut等的回调

​                -----------nextTick()  宏任务的回调

I/O callbacks   （除了时间等的回调函数外）所有事件的回调函数
 
poll队列         新的IO事件，网络连接 数据获取 读取文件  当事件回调队列为空，且timer超时，会去执行timer
check           setImmediate()回调
```

通信

Node 单机下 父子进程通过IPC通道 当创建子进程时，会先创建通信通道，

​    ------通过process.send()发消息 on监听message接受消息

cluster模块 master主控节点创建和销毁进程并与子进程通信，子进程之间不能直接通信、

worker节点负责执行耗时任务。

### electron

chromium + node.js + 原生GUI= electron

浏览器不能直接操作原生GUI能力，集成node.js 可以调用一些系统功能

### 项目

控制不同用户具有页面的权限

在router中，设置两份路由，一份是asyncRouter,(在路由的meta标签上上设置role角色)，一份是constRouter，用户登录成功后，获取用户的info(包含用户的角色），在路由守卫上，根据角色去获取相应 的动态路由的权限集，再使用router的router.addRoutes()添加至路由表中，在生成侧边栏时直接去获取该角色拥有的全部权限集。

后端维护不同的用户具有的不同权限，路由只有一份(在meta标签中，设置access, system:department,当用户具有这个权限集时，才生成导航栏，才有权限进入该页面),当用户通过浏览器跳转页面时，在全局路由守卫出做拦截，---找到要去的页面(to.name,routers),拿到该路由的权限集，如果该页面不限制(没有权限设置，直接next()),否则拿到权限集，判断用户的权限集里是否有这些权限，若有，则next(),否则 重定向到404页面。

对于按钮级别的细粒度控制，则也是由用户维护一份权限集，当该用户点击按钮去获取某个接口时，由后端判断该用户是否具有请求某个接口的能力，若没有，返回无权限

对于404页面

当用户跳转到404页面时，为了用户体验，根据code码，显示不同的页面,并且，

1.在错误页面，能显示回退到首页，以及上一页的按钮，在进入到40x界面后，mounted计时，设置多少秒之后，强制执行回退到上一个页面。this.$router.go(-1)

标签管理

1. watch监听$route，当路由改变时，添加标签（当前标签是否在TagLists中，若存在，不添加）

2. 计算属性返回TagLists,渲染Tag

3. 计算属性缓存TagLists组件，TagList组件中过滤掉meta标签中noCache的组件

4. 删除标签时，通过子组件通信的方式

   ```js
   单个：
   1.若删除的组件与当前路由不匹配，则只更新TagList，不做任何更改
   2.若删除的组件与当前路由匹配， 如果当前组件是最后一个，则要渲染前一个组件(路由跳转)
                             如果当前组件不是最后一个，则要渲染后一个组件(路由跳转)
     更新TagList，sideMenu的openName也要更新
   删除多个：
   1.删除的是 点击右键删除all TagList只保留home，跳转至Home页
   2.删除的是 other 只保留home和当前的路由，页面不跳转      
   ```

5. 给组件设置：value @input事件

​       tag标签绑定click事件，当点击tag时，跳转路由，同时改变组件上的value值，也就是当前的路由

6. 标签的滑动  通过控制body的left进行滑动，显示标签 

   ```ht
   <scroll-outer>
       <scroll-body left="动态改变的值">
   
       </scroll-body>
   </scroll-outer>
   
   
   ```

### rollup

能打包出体积更小的代码，支持es模块,打包形成一个文件，该文件可以是一个库或者一个app

webpack是全部打包，将import语法转化为浏览器能直接运行的代码，当运行，需要什么文件都是可以从打包后的文件中拿出来的。所以打包过程就很慢。

es模块 使用<script type="module"></script> 浏览器会发起请求，去查找该模块

```
常见插件
1. rollup-plugin-node-resolve
编写的源码与依赖的第三方库进行合并，rollup.js为我们提供了resolve插件。
2.external 属性
有些场景下 类库
3.rollup-plugin-commonjs
默认不识别引入的commonjs模块 这种模块当使用module.exports ={}不支持tree-shaking特性 exports.A= xxx才支持，并且引入时只能使用import，当commonjs使用require引入，也不会tree-shaking

@babel/node  命令行工具运行在node环境下的es模块  使用babel将commonjs代码转为es，可以在node环境中使用import等的语法

tree-shaking
只支持es 而当使用下面全量导出时，即使没有使用，也会被打包 不会进行tree-shaking
export default {A,B,C}
使用export A  export B 才会触发tree-shaking
    
es6在编译时 遇到imprort就直接生成一个对导出文件的引用
require 是在运行时才确定的值的使用
treeShaking  是基于es6的静态引用，扫描es6的export,找出被import的内容，并且被使用的模块
webpack是把所有的import标记为有使用/无使用两种
```

### babel

@babel/core并不操作代码，是提供一个API parser  traverse genetator

预设是一些列插件的集合 

@babel/preset-env  将代码(只会转化新的语法，箭头函数)转化为我们需要的模块以及针对不同的平台，当使用新的API promise,Generator时，需要pollify的支持，现在是使用core-js，"useBuiltIns":"usage"  自动检测代码中有需要转化的新特性时，才会引入。或者在plugin中单独设置

@babel/plugin-transform-runtime 多次对垫片中的api引用，只会打包一次

@babel-types 用于构造、验证以及变换AST节点的方法。

visitor 中的path是对路径进行访问，不是对节点，这样可以拿到path.node path.parent.node

### 正则

+ 贪婪匹配  

在量词作用下的表达式会尽可能的尝试匹配满足条件的字符，直到后面的字符串不满足这个表达式或者到达字符串的结尾。 只有表达式整体在尝试匹配却没有匹配成功的情况下，匹配优先的这部分才会归还部分字符，好让整体能够匹配成功。

```js
回溯
1.尽可能多匹配满足条件的字符
2.为了使整体能匹配成功，会归还部分字符，
"(.*)"
"hello world"

第一步：正则表达式的"开始匹配测试用例的第一个字符，发现测试用例的第一个字符也是"，于是正则表达式中的"部分匹配成功。然后开始继续下面的匹配。

第二步：正则表达式的.*是一个整体，表示.可以匹配无数次，或者0次。.是一个元字符可以匹配任何字符（除了行的结束符），所以在遇到行结束符之前，这部分表达式对于接下来的字符都是可以匹配成功的，就像上图表示的那样，一直匹配到这一行的结束。

第三步：正则表达式的第三部分"需要在测试用例中能够匹配到"，但是因为.*已经匹配到测试用例这一行的结尾了，「所以为了正则表达式的整体能够匹配成功，.*需要归还已经匹配到的字符」。在这个例子中，需要把最后匹配的"字符让出来。让正则后面的"这部分尝试匹配，然后发现"可以匹配让出来的"字符，至此，整个匹配过程完成。
```

+ 禁止贪婪 ? 

  在量词作用下尽可能的忽略掉满足条件的字符，只有正则表达式整体在尝试匹配却没有匹配成功的情况下，忽略优先的部分才回去匹配满足条件的那些字符，好让整体能够匹配成功

  为了让整体能匹配成功，我只好带上一部份被忽略的内容

  ```js
  "(.*?)"
  "hello" "world"
  第一步：正则表达式的"开始匹配测试用例的第一个字符，发现测试用例的第一个字符也是"，于是正则表达式中的"部分匹配成功。然后开始继续下面的匹配。
  
  第二步：正则表达式的.*?是一个整体，表示.可以匹配0次或者无数次，「但是尽量不匹配」。于是，刚开始，「.*?就什么也没有匹配」。
  
  第三步：正则表达式的"开始进行匹配，发现h不满足匹配，于是需要进行回溯。也就是.*?要尝试匹配满足条件的字符，为了后面的"能够匹配成功。于是.*?匹配了h，后面的"发现下一个字符是e，还是不可以匹配成功，然后再次进行回溯。一直到.*?匹配了hello，正则表达式的"发现此时后面的"是可以匹配成功的，至此整个表达式匹配成功了一次。
  
  第四步：在接下来的字符串中，重复上述的1-3步骤，一直到字符串的结尾。
  ```

+ 环视匹配

  匹配的是位置,且x不会出现在最后的匹配结果中

  (? = x)  顺序环视  要去找到一个位置，这个位置的右边只能是x

​       (? ! x ) 顺序环视 要去找到一个位置，这个位置的右边不能是x

​       (? <= x) 逆序环视 要去找到一个位置 这个位置的左边必须是x

​       (?<! x)  逆序环视 要去找到一个位置 这个位置的左边不能是x

+ 素数的匹配

  ```js
  // 匹配4个
  (xx+)\1
  xxxxx
  由于贪婪匹配 x会可能多的匹配x 但是后面还有\1---捕获与反引用
  当匹配到了5个x 由于有\1 不满足整体 归还一个x
  当归还后 4个x 由于有\1 不满足整体 归还一个x
  当归还后 3个x 由于有\1  不满足整体 归还一个x
  当归还后 2个x 由于有\1  满足整体  不需要归还 匹配到了4个xxxx
  
  // 匹配6个 8个 匹配到的是合数个数
  (xx+)\1+
      
  // 匹配素数个数 从字符串开头开始匹配 某个位置后面跟着合数个数串 直到字符串末尾 
  ^(?!(xx+)\1+$)
  // ^限制起始位置只能是字符串的开头 不限制 会匹配多个符合的位置 $限制了匹配的是整个字符串结尾 
  ```

### vue源码文章

  http://caibaojian.com/vue-design/art/

​       https://ustbhuangyi.github.io/vue-analysis/v2/prepare/

### 浏览器指纹

+ 插件和扩展

  插件可以调用操作系统API    扩展调用的是浏览器的API 浏览器可控

比cookie更隐蔽，网站可以根据浏览器的指纹，使其不可以注册若干个账号(马甲)

cookie 需要把信息保存在浏览器端，所以会被用户发现，也会被用户清除。

而“浏览器指纹”无需在客户端保存任何信息，不会被用户发觉，用户也无法清除（换句话说：你甚至无法判断你访问的网站到底有没有收集浏览器指纹）。浏览器所能获取的未授权的指纹越来越少

fingerprintjs2 ，结合多个指纹进行验证

1.canvas，webGL, AudioContext 利用硬件或者软件的差异（图片的抗锯齿渲染算法--显卡，压缩等级，音频信号的处理上的差异），生成图片，音频，计算不同的hash作为参考指纹

### vite

利用浏览器自带import功能，只解析，不打包

### webpack require.context

全量导入 第四个参数是引入的全部模块都打包生成一个文件，不再全部打包到app.js下

files(key) 得到类似import的功能 

id:是该引入文件的相对目录

keys:该文件下匹配成功的文件名

resolve(key)：该文件名的相对路径

const files = require.context('./svg', false, /\.svg$/,'lazy-once')

const requireAll = files=> files.keys().map(files)

requireAll(files)

### vue

1. proxy取代defineProperty

2. vdom 重写 在编译时将动态节点进行标记

   +  静态标记

   + 纯静态节点标记

     _createVNode 第四个参数 标记哪些属性是动态的 

     9 /* TEXT, PROPS */, ["onClick", "id"]

     在v-for等的block块内，维护一个动态节点的数组，每次diff，只diff这些
     
     在vue2中，先diff父节点--diff节点的props attrs....====再去diff每次孩子节点，再重复，不管有没有变，直接全部的diff，性能不好。
     
     vue3中，静态block的出现，不需要一个一个的全部diff，只diff发生了改变的。template模板的特点，而直接使用render()少了静态标记的步骤，所以还是推荐写template语法

​    3. diff算法 

​        vue2的时候是双端比较 维护4个变量

​        vue3加入最长递增子序列

